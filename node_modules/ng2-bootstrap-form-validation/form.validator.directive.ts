import { Directive, ElementRef, HostListener, Input, Renderer } from '@angular/core';
import { NgModel, NgForm, FormControl } from '@angular/forms'

declare var $:any;

@Directive({
  selector: '[formValidator]',
  exportAs: 'formValidator',
  providers: [NgForm]
})
export class FormValidatorDirective { 

    _options = {
        container: 'div', //tooltip' 
        validationStart: 'onBlur', //onLoad', //'onSubmit', 'onTyping'
                         // onBlur (default) : Validation starts for any Input field when 
                         //                       1) the Input field is losing focus or 
                         //                       2) the NgModel(input field value) is being changed and the Input field had got focus before
                         // onLoad : Validation will be done once for all input fields after page loaded  
                         // onSubmit : Validation starts when the Form receives OnSubmit event 
                         // onTyping : Validation starts while user tying, no validation for the fields without changes 
        tooltipOptions: null,
        msgDivStyle: 'font-size:80%;text-align:right',
        msgProvider: null,
        validateOnSumbit: true
    }

    private validating = false;

    constructor(private form: ElementRef, private ngForm: NgForm) {
    }

    @Input('formValidator') set options(opt){
        if (opt && typeof opt === 'object') {
            Object.assign(this._options, opt);
            if (!this._options.validationStart) {
                this._options.validationStart = 'onBlur';
            }
        }
    }

    @Input() set validationStart(start) {
        this._options.validationStart = start;
    }

    @Input() set msgContainer(container) {
        this._options.container = container;
    }

    setWarningMsg(formControl:FormControl) {
        let msgContainer = formControl['msgContainer'];
        let input = formControl['__input'];
        if (!msgContainer) {
            if (this._options.container === 'div') {
                msgContainer = new WarningMsgDiv(input, this._options.msgDivStyle);
            } else {
                msgContainer = new WarningMsgTooltip(input, this._options.tooltipOptions);
            }
            formControl['msgContainer'] = msgContainer;            
        } 
        if (formControl.errors) {
            let first;
            for (first in formControl.errors) {
                break;
            }
            let msg = null;
            let err = formControl.errors[first];
            if (this._options.msgProvider) {
                msg = this._options.msgProvider(first, err, input);
            } 
            if (!msg) {
                if (first === 'required') {
                    msg = 'This field is required';
                } else if (first === 'minlength') {
                    msg = 'Minimum length is ' + err['requiredLength'];
                } else if (first === 'maxLength') {
                    msg = 'Maximum length is ' + err['requiredLength'];
                } else {
                    msg = 'This field is not valid'
                }
            }
            if (msgContainer.getMessage() != msg) {
                msgContainer.setMessage(msg);
            }
        }
        let formGroup = $(input).closest('.form-group');
        if (formGroup.length > 0) {
            let clazz = formGroup[0].classList;
            if (!clazz.contains('has-error')) {
                clazz.add('has-error');
            }
        }
        
        return msgContainer;
    }

    clearWarningMsg(formControl:FormControl) {
        let msgContainer = formControl['msgContainer'];
        let input = formControl['__input'];
        if (msgContainer) {
            msgContainer.clear();
            let formGroup = $(input).closest('.form-group');
            if (formGroup.length > 0) {
                let clazz = formGroup[0].classList;
                if (clazz.contains('has-error')) {
                    clazz.remove('has-error');
                }
            }
        }
    }

    //To validate all the input fields 
    //return a list of invalid input fields and its error messages
    invalidateForm():string[] {
        this.validating = true;
        if (this.ngForm.invalid) {
            let firstOne = null;
            let msgs = [];
            for (let key in this.ngForm.controls) {
                let f = this.ngForm.controls[key];
                if (!(f instanceof FormControl))
                    continue;
                if (this._options.validationStart.toLowerCase() === 'onblur') {
                    f['__blurred'] = true;
                }
                if (f.invalid) {
                    let msgContainer = this.setWarningMsg(f);
                    msgs.push(msgContainer.getInputAndMsg());
                    if (!firstOne) {
                        firstOne = f['__input'];
                    }
                }
            }
            if (firstOne) {
                firstOne.scrollIntoView( true );
                firstOne.focus();
            }
            if (msgs.length > 0) {
                return msgs;
            }
        }
        return null;
    }

    validate(formControl, whenStart) {
        if (this.validating  && (whenStart !== 'onblur' || formControl['__blurred'])) {
            if (formControl.invalid) {
                this.setWarningMsg(formControl).show();
            } else {
                this.clearWarningMsg(formControl);
            }
        }
    }

    ngAfterViewInit() {
        
        let that = this;
        let whenStart = that._options.validationStart.toLowerCase();
        if (whenStart !== 'onsubmit') {
            that.validating = true;
        }
        window.setTimeout(function(){
            if (that.ngForm.controls) {
                if (that._options.validateOnSumbit){
                    that.ngForm.ngSubmit.subscribe((s) => {
                        that.invalidateForm();
                        that.validating = true;
                    });
                }
                for (let key in that.ngForm.controls) {
                    let f = that.ngForm.controls[key];
                    if (!(f instanceof FormControl))
                        continue;
                    let formControl : FormControl = f as FormControl;
                    let input = that.form.nativeElement[key];
                    if (!input) {
                        let formGroup = $(that.form.nativeElement).find("div.form-group[data-name='" + key +"']");
                        if (formGroup.length > 0) {
                            input = formGroup.find('input');
                            if (input.length == 0) {
                                input = formGroup.find(':last-child');
                            }
                            if (input.length > 0) {
                                input = input[0];
                            } else {
                                input = null;
                            }
                        }
                    }
                    if (input) {
                        if (whenStart === 'onblur') {
                            $(input).blur( () => {
                                if (!formControl['__blurred']){
                                    formControl['__blurred'] = true;
                                    that.validate(formControl, whenStart);
                                }
                            } );
                        }

                        formControl['__input'] = input;
                        formControl.valueChanges.subscribe((value) => {
                            that.validate(formControl, whenStart);
                        });
                    }
                }
                if (whenStart === 'onload') {
                    that.invalidateForm();
                }
            }
        }, 10);
        
    }
}


interface MessageRender {
    setMessage(msg);
    getMessage();
    show();
    hide();
    clear();
}

class WarningMsgDiv implements MessageRender {

    private div;

    constructor(private input: any, msgDivStyle) {
        let ele = document.createElement('div');
        ele.className = 'warning-msg help-block';
        ele.setAttribute('style', msgDivStyle);
        let formGroup = $(input).closest('.form-group');
        if (formGroup.length > 0) {
            formGroup = formGroup[0];
            if (input.paerntNode == formGroup) {
                formGroup.insertBefore(ele, input.nextSibling);
            } else {
                formGroup.appendChild(ele);
            }
        }
        this.div = ele;
    }

    setMessage(msg) {
        this.div.innerHTML = msg
    }

    getMessage() {
        return this.div.innerHTML;
    }

    getInputAndMsg() {
        return {msg: this.getMessage(), input: this.input};
    }

    show() {
        this.div.style.display = 'block';
    }

    hide(){
        this.div.style.display = 'none';
    }

    clear(){
        this.hide();
        this.setMessage(null);
    }
}

class WarningMsgTooltip implements MessageRender {

    private msg;
    private showing = false;

    constructor(private input: any, private options) {
        $(input).tooltip(options);
    }

    setMessage(msg) {
        this.msg = msg;
        $(this.input).attr('data-original-title', this.msg);
    }

    getMessage(){
        return this.msg;
    }

    getInputAndMsg() {
        return {msg: this.getMessage(), input: this.input};
    }

    show() {
        if (!this.showing) {
            $(this.input).tooltip('show');
            this.showing = true;
        }
    }

    hide(){
        $(this.input).tooltip('hide');
        this.showing = false;
    }

    clear(){
        this.hide();
        this.setMessage(null);
    }
}
